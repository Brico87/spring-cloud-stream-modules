<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Log (log)</title><link rel="stylesheet" type="text/css" href="docbook-epub.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"/><link rel="prev" href="ch04s08.xhtml" title="JDBC (jdbc)"/><link rel="next" href="ch04s10.xhtml" title="RabbitMQ"/></head><body><header/><section class="section" title="Log (log)" epub:type="subchapter" id="spring-cloud-stream-modules-log"><div class="titlepage"><div><div><h2 class="title" style="clear: both">Log (<code class="literal">log</code>)</h2></div></div></div><p>Probably the simplest option for a sink is just to log the data. The <code class="literal">log</code> sink uses the application logger to output the data for inspection. The log level is set to <code class="literal">WARN</code> and the logger name is created from the stream name. To create a stream using a <code class="literal">log</code> sink you would use a command like</p><pre class="literallayout">dataflow:&gt; stream create --name mylogstream --definition "http --server.port=8000 | log" --deploy</pre><p>You can then try adding some data. Weâ€™ve used the <code class="literal">http</code> source on port 8000 here, so run the following command to send a message</p><pre class="literallayout">dataflow:&gt; http post --target http://localhost:8000 --data "hello"</pre><p>and you should see the following output in the Spring Cloud Data Flow console.</p><pre class="literallayout">13/06/07 16:12:18 INFO Received: hello</pre></section><footer/></body></html>